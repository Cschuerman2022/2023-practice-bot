// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.
/*----------------------------------------------------------------------------*/

package frc.robot.commands;
import edu.wpi.first.wpilibj2.command.CommandBase;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc.robot.subsystems.DriveTrain;
import frc.robot.util.OIReporters;
import frc.robot.util.RobotMath;
import frc.robot.util.OIReporters.DriveReporters;
import frc.robot.util.OIReporters.ControllerScaling;
import frc.robot.Constants.DriveConstants;
import frc.robot.util.OIReporters.DriveControllerMode;
import frc.robot.util.OIReporters.DriveType;
import frc.robot.RobotContainer;
import frc.robot.RobotContainer.*;
import java.util.function.DoubleSupplier;

import frc.robot.Constants;
import frc.robot.OI;

/**
 * Creates teleop drivetrain drive command
  * @author 23BBrenner
 */
public class DriveCommand extends CommandBase {

    // DriveCommand Variable Declarations 

    // DriveCommand Constructors

    private DriveTrain m_drivetrain; 
    private RobotContainer m_robotContainer;
    private XboxController m_driveController;
    private OIReporters.DriveControllerMode m_driverControlsChoice;
    private OIReporters.DriveType m_driveTypeChoice;
    private OIReporters.ControllerScaling m_controllerScalingChoice;
    public double speed;
    public double rotation;
       
    public DriveCommand(DriveTrain subsystem, XboxController controller) {
        m_drivetrain = subsystem;
        m_driveController = controller; 
        m_robotContainer = RobotContainer.getInstance();

      

        // Ensures that two commands that need the same subsystem dont mess each other up. 
        addRequirements (m_drivetrain);  
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
        
    }

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
     
        m_driverControlsChoice = m_robotContainer.getOI().getDriverControlsChooser();
        m_driveTypeChoice = m_robotContainer.getOI().getDriveTypeChooser();
        m_controllerScalingChoice = m_robotContainer.getOI().getControllerScalingChooser();

        driverControls(m_driverControlsChoice);
        rotation = (m_driveController.getLeftX() * DriveConstants.kRotationOutputModifier);
        controllerScaling(speed, rotation, m_controllerScalingChoice);
        driveType(speed, rotation, m_driveTypeChoice);

        double leftSpeed = speed + rotation;
        double rightSpeed = speed - rotation;

        double max = Math.max(leftSpeed, rightSpeed);

        if(max > 1) {
			leftSpeed /= max;
			rightSpeed /= max;
		}

        m_drivetrain.setWheelSpeeds(leftSpeed, rightSpeed);
    }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        return false;
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    }

    public void driverControls(OIReporters.DriveControllerMode choice) {
        speed = 0;
        rotation = 0;

            if (choice == DriveControllerMode.TRIGGER_ACCEL){ //accelerate with trigger controls 
                speed = ((m_driveController.getLeftTriggerAxis() - m_driveController.getRightTriggerAxis()) * DriveConstants.kSpeedOutputModifier);

                OIReporters.DriveReporters.driveControllerMode = "Trigger Accel";
                OIReporters.DriveReporters.tAccelSpeed = speed;
                return;

             } 
                //default left stick controls
                speed = m_driveController.getLeftY();// * DriveConstants.kSpeedOutputModifier);
                
                OIReporters.DriveReporters.driveControllerMode = "Left Stick";
                OIReporters.DriveReporters.lStickSpeed = speed;
        }

    public void controllerScaling(double speed, double rotation, OIReporters.ControllerScaling choice){
        OIReporters.DriveReporters.originalSpeed = speed;
        OIReporters.DriveReporters.originalRotation = rotation;

        if (choice == ControllerScaling.LINEAR){ //linear scaling
            this.speed = speed; 
            this.rotation = rotation;

            OIReporters.DriveReporters.scalingMode = "Linear";
            OIReporters.DriveReporters.linearScaled = ("Speed: " + RobotMath.truncate(speed,3) + " & Rotation: " + RobotMath.truncate(rotation, 3));
            return;
        }
        if (choice == ControllerScaling.SQUARED) { //squared scaling
            speed = Math.copySign(speed * speed, speed);
            rotation = Math.copySign(rotation * rotation, rotation);
                
            OIReporters.DriveReporters.scalingMode = "Squared";
            OIReporters.DriveReporters.squaredScaled = ("Speed: " + RobotMath.truncate(speed,3) + " & Rotation: " + RobotMath.truncate(rotation, 3));
            return;
        }
        if (choice == ControllerScaling.CUBIC) { //cubic scaling
            speed = speed * speed * speed;
            rotation = rotation * rotation * rotation;

            OIReporters.DriveReporters.scalingMode = "Cubic";
            OIReporters.DriveReporters.cubicScaled = ("Speed: " + RobotMath.truncate(speed,3) + " & Rotation: " + RobotMath.truncate(rotation, 3));
            return;
        } 
            //non polynomic (fancy)
            speed = speed * 0.5 + Math.pow(3,(speed * 0.5));
            rotation = speed * 0.5 + Math.pow(3,(speed * 0.5));

            OIReporters.DriveReporters.scalingMode = "Fancy";
            OIReporters.DriveReporters.fancyScaled = ("Speed: " + RobotMath.truncate(speed,3) + " & Rotation: " + RobotMath.truncate(rotation, 3));

    }

    public void driveType(double speed, double rotation, OIReporters.DriveType choice){
        if (choice == DriveType.REG_CURVATURE){ //regular curvature
            m_drivetrain.curvatureDrive(speed, rotation, false);

            OIReporters.DriveReporters.driveType = "Curvature";
            OIReporters.DriveReporters.semiCurvature = false;
           return;
        }
        if (choice == DriveType.ARCADE){ //arcade
            m_drivetrain.arcadeDrive(speed, rotation);

            OIReporters.DriveReporters.driveType = "Arcade";
            return;
        }
            //semi-curvature
            m_drivetrain.curvatureDrive(speed,rotation,true);
            
            OIReporters.DriveReporters.driveType = "Semi-Curvature";
            OIReporters.DriveReporters.semiCurvature = true;
    }

    

    
}