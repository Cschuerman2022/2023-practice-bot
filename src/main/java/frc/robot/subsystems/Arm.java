package frc.robot.subsystems;

import frc.robot.Constants;
import frc.robot.OI;
import frc.robot.RobotContainer;
import frc.robot.OIReporters;

import frc.robot.commands.*;
import edu.wpi.first.wpilibj2.command.PIDSubsystem;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.math.MathUtil;

import com.revrobotics.CANSparkMax.*;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;

     

/**
 *
 */
public class Arm extends SubsystemBase {

   
private CANSparkMax j1Turret; 
private CANSparkMax j2Elbow;
private CANSparkMax j3WristX;
private CANSparkMax j4WristY;
private CANSparkMax j5Claw;

private Encoder j1TurretEncoder; 
private Encoder j2ElbowEncoder;
private Encoder j3WristXEncoder;
private Encoder j4WristYEncoder;
private Encoder j5ClawEncoder;
   

    public Arm() {
         
        j1Turret = new CANSparkMax(11, MotorType.kBrushless);
        j2Elbow = new CANSparkMax(12, MotorType.kBrushless);
        j3WristX = new CANSparkMax(13, MotorType.kBrushless);
        j4WristY = new CANSparkMax(14, MotorType.kBrushless);
        j5Claw = new CANSparkMax(15, MotorType.kBrushless);

        j1Turret.restoreFactoryDefaults();  
        j1Turret.setInverted(false);
        j1Turret.setIdleMode(IdleMode.kBrake);
        j1Turret.burnFlash();

        j2Elbow.restoreFactoryDefaults();  
        j2Elbow.setInverted(true);
        j2Elbow.setIdleMode(IdleMode.kBrake);
        j2Elbow.burnFlash();
        
        j3WristX.restoreFactoryDefaults();  
        j3WristX.setInverted(false);
        j3WristX.setIdleMode(IdleMode.kBrake);
        j3WristX.burnFlash();

        j4WristY.restoreFactoryDefaults();  
        j4WristY.setInverted(false);
        j4WristY.setIdleMode(IdleMode.kBrake);
        j4WristY.burnFlash();

        j5Claw.restoreFactoryDefaults();  
        j5Claw.setInverted(false);
        j5Claw.setIdleMode(IdleMode.kBrake);
        j5Claw.burnFlash();
  

        j1TurretEncoder = new Encoder(2, 3, false, EncodingType.k4X);
        addChild("armEncoder",j1TurretEncoder);
        j1TurretEncoder.setDistancePerPulse(1.0);


    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        super.periodic();

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // @Override
    // public double getMeasurement() {
    //     // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
    //     return  armEncoder.getRate();

    // // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
    // }

    // @Override
    // public void useOutput(double output, double setpoint) {
    //     output += setpoint*kF;
    //     // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
    // armMotor.set(output);

    // // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
    // }

    public double getAngle() {
        return 0;
      }

    public Object rotateArm(double output) {
        return null;
    }

}
